<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
  <script src="https://unpkg.com/axios/dist/axios.min.js"></script>
  <meta name="viewport" content="width=device-width,initial-scale=1.0">
  <title>REVERSI</title>
</head>
<body>
  <div id="app">
    <div @click="onClickMenu" v-show="menu === 'close'" class="menu-open">&gt;</div>
    <header :class="menu">
      <div @click="onClickMenu" class="menu-close">&lt;</div>
      <h1 @click="onClickMenu">REVERSI</h1>
      <div class="menu">
        <table>
          <tr>
            <td>player {{ userColor }}</td>
            <td>current: {{ currentPlayer }}</td>
          </tr>
          <tr>
            <td>x: <input type="number" v-model="game.boardSize.x"></td>
            <td>y: <input type="number" v-model="game.boardSize.y"></td>
          </tr>
          <tr>
            <td>セルのサイズ</td>
            <td><input type="number" v-model="cellScale"></td>
          </tr>
          <tr>
            <td>white: {{ game.white }}</td>
            <td>black: {{ game.black }}</td>
          </tr>
          <tr>
            <td colspan=2><div>{{ game.state === 'on going' ? 'status' : 'winner'}}: {{ game.state }}</div></td>
          </tr>
          <tr>
            <td colspan=2>
              <div>
                <button @click="onClickUpdateBoardSize">Restart</button>
                <button @click="onClickReset" class="reset">reset</button>
                <span>AUTO: <input type="checkbox" v-model="auto"></span>
              </div>
            </td>
          </tr>
        </table>
      </div>
      <div class="moves">
        <div v-if="game.state == 'on going' && !auto">
          <template v-for="(move, index) in game.moves" :key="move.index">
            <button @click="onClickPass" v-if="move === 'pass'">パス</button>
            <button
              v-else
              @click="onClickMoveButton(move.index)"
              @mouseover="onMouseoverMoveButton(move.index)"
              @mouseleave="onMouseleaveMoveButton(move.index)"
            >{{ move.index }}</button>
          </template>
        </div>
      </div>
    </header>
    <main>
      <table class="board" :style="cellSize">
        <tr v-for="(line, index) in board" :key="index">
          <td
            v-for="cell in line"
            :key="cell.index"
            :ref="'cell_' + cell.index"
            :class="['cell_' + cell.index, game.moves[cell.index] ? 'movable' : null]"
            @mouseover="onMouseoverMoveButton(cell.index)"
            @mouseleave="onMouseleaveMoveButton(cell.index)"
            @click="onClickMoveButton(cell.index)"
          >
            <span class="cellState" :class="cellStateClass(cell.state)"></span>
          </td>
        </tr>
      </table>
    </main>
  </div>
</body>
</html>

<script>
  <?php echo "const boardFromPhp = JSON.parse('${gameJson}')" . PHP_EOL ?>

  const boardMatrix = (board) => {
    const matrix = {}
    for (index in board) {
      const group = 'y' + board[index].y
      if (!matrix[group]) {
        matrix[group] = []
      }
      matrix[group].push(board[index])
    }
    return matrix
  }

  axios.interceptors.request.use((config) => {
    if (config.method === 'post') {
      config.headers = {'Content-Type': 'application/x-www-form-urlencoded'}
      return config
    }
    return config
  })
  const { createApp } = Vue

  createApp({
    data() {
      const cellScale = localStorage.getItem('cellScale') ? localStorage.getItem('cellScale') : 20
      return {
        board: boardMatrix(boardFromPhp.board),
        game: boardFromPhp,
        auto: false,
        currentPlayer: boardFromPhp.currentPlayer,
        userColor: 'white',
        cellScale,
        strategy: 'random',
        menu: 'close',
      }
    },
    watch: {
      auto() {
        if (this.auto) {
          this.compute()
        }
      },
      cellScale() {
        localStorage.setItem('cellScale', this.cellScale)
      }
    },
    computed: {
      cellSize() {
        return {
          '--cell-size': this.cellScale + 'px'
        }
      }
    },
    methods: {
      async updateBoard() {
        const board = await axios.get('/board')
        this.update(board)
      },
      update(response) {
        this.board = boardMatrix(response.data.board)
        this.game = response.data
        this.currentPlayer = response.data.currentPlayer
        if (!this.isMyTurn() || this.auto) {
          if (this.game.state === 'on going') {
            this.compute()
          }
        }
      },
      isMyTurn() {
        return this.currentPlayer.toLowerCase() === this.userColor
      },
      cellStateClass(state) {
        switch(state) {
          case 'white':
            return 'cell-white'
          case 'black':
            return 'cell-black'
          default:
            return 'empty'
        }
      },
      compute() {
        axios.post('/compute').then(this.update)
      },
      onClickMoveButton(move) {
        if (!this.game.moves[move]) {
          return
        }
        this.onMouseleaveMoveButton(move)
        this.currentPlayer = null
        axios.post('/move', { index: move })
          .then(this.update)
      },
      onClickPass() {
        axios.post('/pass').then(this.updateBoard)
      },
      onClickReset() {
        this.auto = false
        this.cellScale = 20
        localStorage.setItem('cellScale', 20)
        this.strategy = 'random'
        axios.post('/reset').then(this.updateBoard)
      },
      onMouseoverMoveButton(move) {
        if (!this.isMyTurn() || this.auto || !this.game.moves[move]) {
          return
        }
        const cells = this.game.moves[move].flipCells.map(c => c).concat([move])
        for (const cell of cells) {
          const dom = this.$refs['cell_' + cell]
          dom[0].classList.add('onMouseoverMove')
          if (cell === move) {
            const addClass = this.currentPlayer === 'BLACK' ? 'cell-white' : 'cell-black'
            dom[0].children[0].classList.add(addClass)
          }
        }
      },
      onMouseleaveMoveButton(move) {
        if (!this.game.moves[move]) {
          return
        }
        const cells = this.game.moves[move].flipCells.map(c => c).concat([move])
        for (const cell of cells) {
          const dom = this.$refs['cell_' + cell]
          dom[0].classList.remove('onMouseoverMove')
          if (cell === move) {
            const addClass = this.currentPlayer === 'BLACK' ? 'cell-white' : 'cell-black'
            dom[0].children[0].classList.remove(addClass)
          }
        }
      },
      onClickUpdateBoardSize() {
        axios.post('/reset', {
          boardSizeX: this.game.boardSize.x,
          boardSizeY: this.game.boardSize.y,
          strategy: this.strategy,
        }).then(this.updateBoard)
      },
      onClickMenu() {
        if (this.menu === 'open') {
          this.menu = 'close'
        } else {
          this.menu = 'open'
        }
      }
    }
  }).mount('#app')
</script>

<style>
  body {
    margin: 0;
  }
  .board {
    border-spacing: 0;
    border-collapse: collapse;
    box-shadow: 1px 2px 0.4px 0.1px rgb(0 0 0 / 20%);
    border: 1px solid #999;
    margin: 10px auto;
  }
  .board td {
    border: calc(var(--cell-size) / 100) solid #666;
    width: calc(var(--cell-size) + var(--cell-size) / 4);
    height: calc(var(--cell-size) + var(--cell-size) / 4);
    background-color: #00d202;
  }
  .board td.onMouseoverMove {
    background-color: #92ff9d;
  }
  .board td.movable {
    cursor: pointer;
  }

  .cellState {
    margin: auto;
    display: block;
  }
  .cellState.cell-white {
    background-color: #fafafa;
    width: var(--cell-size);
    height: var(--cell-size);
    border-radius: calc(var(--cell-size) / 2);
    border: calc(var(--cell-size) / 20) solid #333;
    box-shadow: 1px 2px 0.4px 0.1px rgb(0 0 0 / 20%);
  }
  .cellState.cell-black {
    background-color: #232323;
    width: var(--cell-size);
    height: var(--cell-size);
    border-radius: calc(var(--cell-size) / 2);
    border: calc(var(--cell-size) / 20) solid #333;
    box-shadow: 1px 2px 0.4px 0.1px rgb(0 0 0 / 20%);
  }
  .cellState.empty {
    width: var(--cell-size);
    height: var(--cell-size);
  }
  .board td.onMouseoverMove .cellState.cell-white {
    background-color: rgba(35,35,35,0.5);
  }
  .board td.onMouseoverMove .cellState.cell-black {
    background-color: rgba(250,250,250,.5);
  }

  .moves {
    background: rgba(0, 2, 8, .3);
    margin: 10px auto;
    padding: 10px;
    display: flex;
    justify-content: center;
    flex-direction: column;
    align-items: center;
  }
  .moves div {
    display: flex;
    flex-direction: row;
    flex-wrap: wrap;
    justify-content: center;
    gap: 5px;
    overflow: scroll;
    height: 300px;
  }
  .moves button, .menu button {
    background: #eee;
    color: #666;
    border: 0.3px solid #999;
    border-radius: 3px;
    padding: 3px 10px;
    transition: background 0.2s;
  }
  .moves button:hover, .menu button:hover {
    background: #fff;
    cursor: pointer;
  }

  header {
    position: fixed;
    background: rgba(66,200,150,.5);
    box-shadow: 1px 2px 2px 2px rgb(0 0 0 / 10%);
    border-right: .1px solid #999;
    height: 100%;
    transition: left .2s;
    left: 0;
    top: 0;
    padding: 5px 15px;
    width: 350px;
    color: #666;
  }
  header.close {
    left: -500px;
  }
  header > h1 {
    width: 100%;
  }
  .menu-open {
    position: fixed;
    top: 0;
    left: 0;
    background: rgba(66,200,150,.5);
    box-shadow: 1px 2px 2px 2px rgb(0 0 0 / 10%);
    border-right: .1px solid #999;
    height: 100%;
    padding: 5px 5px;
    color: #666;
  }
  .menu-close {
    position: relative;
    left: 0;
    text-align: end;
    width: 100%;
    color: #666;
    padding: 3px 5px;
  }
  .menu table {
    border-spacing: 0;
    border-collapse: collapse;
    background: rgba(255,255,255,.3);
  }
  .menu table td {
    border: 0.5px solid;
    padding: 3px 5px;
  }
  .menu button {
    margin: 3px 5px;
  }
  .menu button.reset {
    background: #ff1717;
    color: #fff;
  }
  .menu button.reset:hover {
    background: #f3cc88;
  }

</style>
